{
  "version": 3,
  "sources": ["../../client-typescript/telnet_negotiation.ts", "../../client-typescript/websocket.ts"],
  "sourcesContent": ["enum Options {\r\n    ECHO = 1,\r\n    MUDServerStatusProtocolVariable = 1,\r\n    MUDServerStatusProtocolValue = 2,\r\n    SupressGoAhead = 3,\r\n    TelnetType = 24,\r\n    MUDServerStatusProtocol = 70,\r\n    MUDSoundProtocol = 90,\r\n    MUDeXtensionProtocol = 91,\r\n    SubNegotiationEnd = 240,\r\n    GoAhead = 249,\r\n    SubNegotiation = 250,\r\n    WILL = 251,\r\n    DO = 253,\r\n    WONT = 252,\r\n    DONT = 254,\r\n    InterpretAsCommand = 255,\r\n}\r\n\r\nexport class TelnetOption {\r\n    public Enabled: boolean = false;\r\n}\r\n\r\nexport class EchoOption extends TelnetOption {}\r\n\r\nexport class SupressGoAhead extends TelnetOption {}\r\n\r\nexport class NegotiateResponse {\r\n    public NewInput: Uint8Array = new Uint8Array();\r\n    public Response: Uint8Array = new Uint8Array();\r\n}\r\n\r\nexport class TelnetNegotiator {\r\n    public Options: Array<TelnetOption> = [];\r\n    private SupportedClientTypes: Array<string> = [\"256COLOR\", \"VT100\", \"ANSI\", \"TRUECOLOR\"];\r\n    private NegotiatedClientTypes: Array<string> = [];\r\n    private currentTypeIndex: number = -1;\r\n\r\n    private readonly ClientNegotiateTelnetType: Uint8Array = new Uint8Array([\r\n        Options.InterpretAsCommand,\r\n        Options.SubNegotiation,\r\n        Options.TelnetType,\r\n        0\r\n    ]);\r\n\r\n    public IsNegotiationRequired(input: Uint8Array): boolean {\r\n        return input.includes(Options.InterpretAsCommand);\r\n    }\r\n\r\n    public Negotiate(input: Uint8Array): NegotiateResponse {\r\n        const response = new NegotiateResponse();\r\n        let i = 0;\r\n        let lastIndex = 0;\r\n        \r\n        while (i < input.length) {\r\n            if (input[i] === Options.InterpretAsCommand) {\r\n                response.NewInput = this.concatUint8Arrays(response.NewInput, input.slice(lastIndex, i));\r\n                i++; // Move past IAC\r\n                if (i >= input.length) break;\r\n\r\n                const command = input[i];\r\n                i++; // Move past command\r\n\r\n                switch (command) {\r\n                    case Options.DO:\r\n                    case Options.DONT:\r\n                    case Options.WILL:\r\n                    case Options.WONT:\r\n                        if (i >= input.length) break;\r\n                        const option = input[i];\r\n                        i++; // Move past option\r\n                        response.Response = this.concatUint8Arrays(response.Response, this.handleCommand(command, option));\r\n                        break;\r\n                    \r\n                    case Options.SubNegotiation:\r\n                        const subNegResponse = this.handleSubNegotiation(input.slice(i));\r\n                        response.Response = this.concatUint8Arrays(response.Response, subNegResponse);\r\n                        i += this.findSubNegotiationEnd(input.slice(i)) + 1;\r\n                        break;\r\n                }\r\n                lastIndex = i;\r\n            } else {\r\n                i++; // Move to next character if not IAC\r\n            }\r\n        }\r\n        \r\n        response.NewInput = this.concatUint8Arrays(response.NewInput, input.slice(lastIndex));\r\n\r\n        return response;\r\n    }\r\n\r\n    private handleCommand(command: number, option: number): Uint8Array {\r\n        switch (option) {\r\n            case Options.TelnetType:\r\n                if (command === Options.DO || command === Options.WILL) {\r\n                    return this.SendNextClientType();\r\n                }\r\n                break;\r\n            // Add more cases for other options as needed\r\n        }\r\n        return new Uint8Array();\r\n    }\r\n\r\n    private handleSubNegotiation(input: Uint8Array): Uint8Array {\r\n        if (input[0] === Options.TelnetType && input[1] === 1) {\r\n            return this.SendNextClientType();\r\n        }\r\n        return new Uint8Array();\r\n    }\r\n\r\n    private findSubNegotiationEnd(input: Uint8Array): number {\r\n        for (let i = 0; i < input.length - 1; i++) {\r\n            if (input[i] === Options.InterpretAsCommand && \r\n                input[i + 1] === Options.SubNegotiationEnd) {\r\n                return i + 1;\r\n            }\r\n        }\r\n        return input.length;\r\n    }\r\n\r\n    public SendNextClientType(): Uint8Array {\r\n        this.currentTypeIndex = (this.currentTypeIndex + 1) % this.SupportedClientTypes.length;\r\n        const clientType = this.SupportedClientTypes[this.currentTypeIndex];\r\n        \r\n        const clientTypeBytes = new TextEncoder().encode(clientType);\r\n        return this.concatUint8Arrays(\r\n            this.ClientNegotiateTelnetType,\r\n            clientTypeBytes,\r\n            new Uint8Array([Options.InterpretAsCommand, Options.SubNegotiationEnd])\r\n        );\r\n    }\r\n\r\n    private concatUint8Arrays(...arrays: Uint8Array[]): Uint8Array {\r\n        const totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const array of arrays) {\r\n            result.set(array, offset);\r\n            offset += array.length;\r\n        }\r\n        return result;\r\n    }\r\n}", "// websocket.ts\n\nimport { TelnetNegotiator, NegotiateResponse } from './telnet_negotiation';\n\n/**\n * Type definition for a function that handles messages\n */\ntype MessageHandler = (message: string) => void;\n\n/**\n * Type definition for a function that handles connection events\n */\ntype ConnectionHandler = () => void;\n\n/**\n * WebSocketManager class\n * Manages WebSocket connections for a MUD client\n */\nexport class WebSocketManager {\n    private negotiator: TelnetNegotiator = new TelnetNegotiator();\n\n    // The WebSocket instance\n    private socket: WebSocket | null = null;\n    \n    // Handler for outputting messages (e.g., to the UI)\n    private outputHandler: MessageHandler;\n    \n    // Handler for processing input messages\n    private inputHandler: MessageHandler;\n    \n    // Handler called when a connection is established\n    private onConnectHandler: ConnectionHandler;\n\n    public port: number;\n    /**\n     * Constructor for WebSocketManager\n     * @param outputHandler Function to handle output messages\n     * @param inputHandler Function to handle input messages\n     * @param onConnectHandler Function to call when connection is established\n     */\n    constructor(\n        outputHandler: MessageHandler,\n        inputHandler: MessageHandler,\n        onConnectHandler: ConnectionHandler,\n        port: number\n    ) {\n        this.outputHandler = outputHandler;\n        this.inputHandler = inputHandler;\n        this.onConnectHandler = onConnectHandler;\n        this.port = port;\n    }\n\n    private handleMessage(event: MessageEvent) {\n        if (event.data instanceof ArrayBuffer) {\n            // Handle binary data\n            const uint8Array = new Uint8Array(event.data);\n            //console.log(\"Received binary data:\", uint8Array);\n            \n            // Process the binary data\n            this.processBinaryData(uint8Array);\n        } else if (typeof event.data === \"string\") {\n            // Handle text data\n            //console.log(\"Received text data:\", event.data);\n            this.processTextData(event.data);\n        } else {\n            console.warn(\"Received unknown data type:\", typeof event.data);\n        }\n    }\n\n    private processBinaryData(data: Uint8Array) {\n        if (this.negotiator.IsNegotiationRequired(data)) {\n            const response: NegotiateResponse = this.negotiator.Negotiate(data);\n            if (response.Response.length > 0) {\n                this.sendResponse(response.Response);\n            }\n            if (response.NewInput.length > 0) {\n                this.outputHandler(new TextDecoder().decode(response.NewInput));\n            }\n        } else {\n            this.outputHandler(new TextDecoder().decode(data));\n        }\n    }\n\n    private processTextData(data: string) {\n        this.outputHandler(data);\n    }\n\n    private sendResponse(response: Uint8Array) {\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n            this.socket.send(response);\n        }\n    }\n\n    disconnect(): void {\n        if(this.socket != null) {\n            this.socket.close();\n            this.socket = null;\n        }\n    }\n    /**\n     * Establishes a WebSocket connection to the server\n     */\n    connect(): void {\n        this.disconnect();\n        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n        const host = window.location.hostname;\n        const port = this.port;\n\n        this.socket = new WebSocket(`${protocol}//${host}:${port}`);\n\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.onmessage = this.handleMessage.bind(this);\n\n        this.socket.onopen = (e: Event) => {\n            this.outputHandler('Connected to MUD server\\n');\n            this.onConnectHandler();\n        };\n\n        this.socket.onclose = (event: CloseEvent) => {\n            const message = event.wasClean\n                ? `Connection closed cleanly, code=${event.code} reason=${event.reason}\\n`\n                : '\\nConnection died\\n';\n            this.outputHandler(message);\n        };\n\n        this.socket.onerror = (error: Event) => {\n            this.outputHandler(`\\nError: ${(error as ErrorEvent).message}\\n`);\n        };\n    }\n\n    /**\n     * Sends a message through the WebSocket connection\n     * @param message The message to send as a string\n     */\n    sendMessage(message: string): void {\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n            // Only append a newline if the message doesn't already end with one\n            const messageToSend = message.endsWith('\\n') ? message : message + '\\n';\n            const uint8Array = new TextEncoder().encode(messageToSend);\n            this.socket.send(uint8Array);\n            this.inputHandler(message);\n        } else {\n            this.outputHandler('Not connected. Type /connect to connect to the MUD server.\\n');\n        }\n    }\n\n    /**\n     * Checks if the WebSocket connection is currently open\n     * @returns true if connected, false otherwise\n     */\n    isConnected(): boolean {\n        return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n    }\n}"],
  "mappings": "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",
  "names": ["NegotiateResponse", "TelnetNegotiator", "input", "response", "i", "lastIndex", "command", "option", "subNegResponse", "clientType", "clientTypeBytes", "arrays", "totalLength", "acc", "value", "result", "offset", "array", "WebSocketManager", "outputHandler", "inputHandler", "onConnectHandler", "port", "TelnetNegotiator", "event", "uint8Array", "data", "response", "protocol", "host", "e", "message", "error", "messageToSend"]
}
